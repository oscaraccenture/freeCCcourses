# SQL theory



***

## Order By

| Function/Parameter | Description | Examples |
| :--- | :--- | :--- |
| **ORDER BY** | A SQL clause used to sort the result set of a query in ascending or descending order based on one or more columns. | `SELECT * FROM Customers ORDER BY CustomerName;` <br> `SELECT ProductName, Price FROM Products ORDER BY Price DESC;` |
| `column_name` | The name of the column you want to sort the results by. You can specify multiple columns, separated by commas. | `SELECT FirstName, LastName FROM Employees ORDER BY LastName ASC, FirstName ASC;` <br> (Sorts by `LastName` ascending, then by `FirstName` ascending for rows with the same `LastName`) |
| `expression` | A valid expression that can be evaluated for each row in the result set. The results will be sorted based on the value of this expression. | `SELECT ProductName, (UnitPrice * Quantity) AS TotalValue FROM OrderDetails ORDER BY TotalValue DESC;` <br> (Sorts by the calculated `TotalValue` in descending order) <br> <br> `SELECT Name, Category FROM Products ORDER BY CASE WHEN Category = 'Electronics' THEN 1 ELSE 2 END, Name;` <br> (Sorts 'Electronics' products first, then all other products, and within each group, sorts by `Name`) |
| `ASC` | (Optional) Specifies that the results should be sorted in ascending order. This is the default behavior if no keyword is specified. | `SELECT City, Population FROM Cities ORDER BY Population ASC;` <br> (Same as `SELECT City, Population FROM Cities ORDER BY Population;`) |
| `DESC` | (Optional) Specifies that the results should be sorted in descending order. | `SELECT StudentName, Grade FROM Students ORDER BY Grade DESC;` |


## Where

| Function/Parameter | Description | Examples |
| :--- | :--- | :--- |
| **WHERE** | A SQL clause used to filter rows from a result set based on a specified condition or set of conditions. It is used with `SELECT`, `UPDATE`, and `DELETE` statements. | `SELECT * FROM Orders WHERE OrderDate = '2025-07-24';` <br> `UPDATE Products SET Price = Price * 1.10 WHERE Category = 'Electronics';` <br> `DELETE FROM Employees WHERE HireDate < '2020-01-01';` |
| `condition` | A boolean expression that evaluates to TRUE, FALSE, or UNKNOWN for each row. Only rows for which the condition evaluates to TRUE are included in the result set or affected by the statement. This can involve: | |
| **Comparison Operators** | Used to compare values. | `SELECT * FROM Customers WHERE Age > 30;` <br> `SELECT ProductName FROM Products WHERE Price <= 50.00;` <br> `SELECT OrderID FROM Orders WHERE CustomerID <> 105;` (Not equal to) |
| **Logical Operators** | Used to combine multiple conditions. | `SELECT * FROM Employees WHERE Department = 'Sales' AND Salary > 60000;` <br> `SELECT City FROM Locations WHERE Country = 'USA' OR Country = 'Canada';` <br> `SELECT ItemName FROM Inventory WHERE NOT InStock = 0;` |
| **`LIKE`** | Used to search for a specified pattern in a column. Wildcard characters (`%` for any sequence of characters, `_` for any single character) are used with `LIKE`. | `SELECT Name FROM Users WHERE Name LIKE 'A%';` (Starts with 'A') <br> `SELECT ItemCode FROM Items WHERE ItemCode LIKE '_B%';` (Second character is 'B') |
| **`IN`** | Used to specify multiple possible values for a column. | `SELECT CustomerName FROM Customers WHERE City IN ('New York', 'Los Angeles', 'Chicago');` |
| **`BETWEEN`** | Used to select values within a given range (inclusive). | `SELECT OrderID, OrderDate FROM Orders WHERE OrderDate BETWEEN '2025-07-01' AND '2025-07-31';` <br> `SELECT ProductID FROM Products WHERE Price BETWEEN 20 AND 100;` |
| **`IS NULL` / `IS NOT NULL`** | Used to test for NULL values. | `SELECT Email FROM Users WHERE Email IS NULL;` <br> `SELECT ContactNumber FROM Suppliers WHERE ContactNumber IS NOT NULL;` |
| **Subqueries** | A `SELECT` statement nested inside another SQL statement. The subquery's result is used in the `WHERE` clause. | `SELECT ProductName FROM Products WHERE ProductID IN (SELECT ProductID FROM OrderDetails WHERE Quantity > 5);` <br> (Selects products that have been ordered in quantities greater than 5) |


## Logic Operators

| Operator | Description | Examples |
| :--- | :--- | :--- |
| **AND** | Combines two or more conditions. Returns `TRUE` only if *all* the combined conditions are `TRUE`. | `SELECT * FROM Employees WHERE Department = 'Sales' AND Salary > 60000;` <br> (Selects employees who are in 'Sales' AND earn more than 60000) <br> <br> `SELECT OrderID FROM Orders WHERE OrderDate BETWEEN '2025-01-01' AND '2025-01-31' AND CustomerID = 101;` <br> (Selects orders from January 2025 placed by CustomerID 101) |
| **OR** | Combines two or more conditions. Returns `TRUE` if *any* of the combined conditions are `TRUE`. | `SELECT * FROM Products WHERE Category = 'Electronics' OR Price < 100;` <br> (Selects products that are 'Electronics' OR have a price less than 100) <br> <br> `SELECT CustomerName FROM Customers WHERE City = 'Buenos Aires' OR Country = 'Argentina';` <br> (Selects customers from 'Buenos Aires' OR from 'Argentina') |
| **NOT** | Negates a condition. Returns `TRUE` if the condition is `FALSE`, and `FALSE` if the condition is `TRUE`. | `SELECT * FROM Students WHERE NOT Grade = 'F';` <br> (Selects students whose grade is NOT 'F') <br> <br> `SELECT ProductName FROM Inventory WHERE NOT QuantityInStock = 0;` <br> (Selects products that are NOT out of stock) <br> <br> `SELECT EmployeeName FROM Employees WHERE NOT (Department = 'HR' AND Salary > 70000);` <br> (Selects employees who are NOT in HR AND earning more than 70000) |


## Aggregation Functions

| Function | Description | Examples |
| :--- | :--- | :--- |
| **COUNT()** | Returns the number of rows that match a specified criterion. Can be used with `*` to count all rows, or a column name to count non-NULL values. | `SELECT COUNT(*) FROM Employees;` <br> (Counts all employees) <br> <br> `SELECT COUNT(DISTINCT City) FROM Customers;` <br> (Counts the number of unique cities where customers reside) <br> <br> `SELECT COUNT(PhoneNumber) FROM Users WHERE Country = 'Argentina';` <br> (Counts users in Argentina with a non-NULL phone number) |
| **SUM()** | Calculates the total sum of a numeric column. | `SELECT SUM(Price) FROM Products;` <br> (Calculates the sum of all product prices) <br> <br> `SELECT SUM(Quantity) AS TotalQuantitySold FROM OrderDetails WHERE ProductID = 123;` <br> (Calculates the total quantity sold for a specific product) |
| **AVG()** | Calculates the average value of a numeric column. | `SELECT AVG(Salary) FROM Employees WHERE Department = 'Sales';` <br> (Calculates the average salary of employees in the 'Sales' department) <br> <br> `SELECT AVG(Rating) FROM Reviews WHERE ProductID = 456;` <br> (Calculates the average rating for a specific product) |
| **MIN()** | Returns the minimum value in a column. | `SELECT MIN(OrderDate) FROM Orders;` <br> (Finds the earliest order date) <br> <br> `SELECT MIN(Price) FROM Products WHERE Category = 'Electronics';` <br> (Finds the lowest price among electronic products) |
| **MAX()** | Returns the maximum value in a column. | `SELECT MAX(SaleAmount) FROM DailySales;` <br> (Finds the highest daily sale amount) <br> <br> `SELECT MAX(HireDate) FROM Employees;` <br> (Finds the latest employee hire date) |
| **GROUP_CONCAT()** (MySQL) / **STRING_AGG()** (SQL Server, PostgreSQL) / **LISTAGG()** (Oracle) | Concatenates strings from a group into a single string. (Note: Function name varies by database system). | **MySQL:** <br> `SELECT Department, GROUP_CONCAT(EmployeeName ORDER BY EmployeeName SEPARATOR ', ') FROM Employees GROUP BY Department;` <br> (Lists all employee names, separated by commas, for each department) <br> <br> **SQL Server/PostgreSQL:** <br> `SELECT Category, STRING_AGG(ProductName, ', ') FROM Products GROUP BY Category;` <br> (Lists all product names, separated by commas, for each category) |


## Group BY and HAVING

| Clause/Parameter | Description | Examples |
| :--- | :--- | :--- |
| **GROUP BY** | Groups rows that have the same values in specified columns into summary rows. It is often used with aggregate functions (like `COUNT`, `SUM`, `AVG`, `MIN`, `MAX`) to perform calculations on each group. | `SELECT Department, COUNT(*) AS NumberOfEmployees FROM Employees GROUP BY Department;` <br> (Counts employees in each department) <br> <br> `SELECT CustomerID, SUM(OrderTotal) AS TotalSpent FROM Orders GROUP BY CustomerID;` <br> (Calculates the total amount spent by each customer) <br> <br> `SELECT YEAR(OrderDate) AS OrderYear, MONTH(OrderDate) AS OrderMonth, SUM(TotalAmount) FROM Sales GROUP BY YEAR(OrderDate), MONTH(OrderDate);` <br> (Calculates monthly sales totals for each year) |
| `column_name(s)` | One or more columns by which you want to group the result set. All non-aggregated columns in the `SELECT` list must be included in the `GROUP BY` clause. | `SELECT Category, AVG(Price) FROM Products GROUP BY Category;` <br> (Calculates the average price for products in each category) |
| `expression` | An expression that evaluates for each row, and rows with the same expression result are grouped. | `SELECT CASE WHEN Price < 50 THEN 'Low' WHEN Price BETWEEN 50 AND 200 THEN 'Medium' ELSE 'High' END AS PriceRange, COUNT(*) FROM Products GROUP BY PriceRange;` <br> (Counts products within defined price ranges) |
| **HAVING** | Filters groups based on a specified condition. It is similar to the `WHERE` clause but operates on the results of `GROUP BY` and aggregate functions, rather than individual rows. `HAVING` must appear after `GROUP BY`. | `SELECT Department, AVG(Salary) AS AverageSalary FROM Employees GROUP BY Department HAVING AVG(Salary) > 60000;` <br> (Finds departments where the average salary is greater than 60000) <br> <br> `SELECT ProductID, SUM(Quantity) AS TotalSold FROM OrderDetails GROUP BY ProductID HAVING SUM(Quantity) >= 100;` <br> (Identifies products that have sold 100 or more units) <br> <br> `SELECT CustomerID, COUNT(OrderID) AS NumberOfOrders FROM Orders GROUP BY CustomerID HAVING COUNT(OrderID) > 5 AND SUM(OrderTotal) > 500;` <br> (Finds customers who placed more than 5 orders AND spent over 500) |
| `search_condition` | A boolean expression that filters the grouped rows. It can include aggregate functions. | (See examples under `HAVING` above, as the `search_condition` is the core of the `HAVING` clause.) |



## Sub queries

| Concept | Description | Examples | Tips and Considerations |
| :--- | :--- | :--- | :--- |
| **Subquery** <br> (Inner Query, Nested Query) | A query nested inside another SQL query. It can be used in various SQL clauses, including `SELECT`, `FROM`, `WHERE`, `HAVING`, and `EXISTS`. The inner query executes first, and its result is used by the outer query. | **In `WHERE` clause:** <br> `SELECT ProductName FROM Products WHERE CategoryID = (SELECT CategoryID FROM Categories WHERE CategoryName = 'Electronics');` <br> (Finds products in the 'Electronics' category) <br> <br> **In `FROM` clause (Derived Table):** <br> `SELECT AVG(SubTotal) FROM (SELECT CustomerID, SUM(OrderTotal) AS SubTotal FROM Orders GROUP BY CustomerID) AS CustomerTotals;` <br> (Calculates the average total spending across all customers) <br> <br> **In `SELECT` clause (Scalar Subquery):** <br> `SELECT EmployeeName, (SELECT DepartmentName FROM Departments WHERE Employees.DepartmentID = Departments.DepartmentID) AS EmployeeDepartment FROM Employees;` <br> (Adds department name as a column to employee details) <br> <br> **With `EXISTS`:** <br> `SELECT CustomerName FROM Customers WHERE EXISTS (SELECT OrderID FROM Orders WHERE Orders.CustomerID = Customers.CustomerID);` <br> (Finds customers who have placed at least one order) | **Readability:** Keep subqueries as simple as possible. Complex nested subqueries can be hard to read and debug. <br> <br> **Performance:** Often, `JOIN` operations can be more efficient than subqueries, especially for larger datasets. Test both approaches. <br> <br> **Scalar Subqueries:** Must return exactly one row and one column. If they return no rows, the result is `NULL`. If they return multiple rows, an error occurs. <br> <br> **Correlated vs. Non-Correlated:** <br> - **Non-correlated:** The inner query executes independently and once. <br> - **Correlated:** The inner query depends on the outer query for its values and executes once for *each row* processed by the outer query. These can be less performant. <br> <br> **`IN` vs. `EXISTS`:** <br> - `IN` is good when the inner query returns a small set of distinct values. <br> - `EXISTS` is often more efficient when you just need to check for the *existence* of any matching row, rather than fetching specific values. <br> <br> **Aliasing Derived Tables:** When using subqueries in the `FROM` clause (derived tables), you *must* provide an alias (e.g., `AS CustomerTotals`). <br> <br> **Debugging:** Break down complex queries into smaller subqueries or temporary tables to debug step by step. <br> <br> **Alternative Solutions:** Always consider if a `JOIN`, `CTE` (Common Table Expression), or window function might offer a more elegant or performant solution. |
| **Correlated Subquery** | A subquery that references a column from the outer query. It executes once for each row processed by the outer query. | `SELECT EmployeeName, Salary FROM Employees e WHERE Salary > (SELECT AVG(Salary) FROM Employees WHERE DepartmentID = e.DepartmentID);` <br> (Finds employees whose salary is greater than the average salary of their own department) | **Performance Impact:** Can be less performant than non-correlated subqueries or joins due to repeated execution. <br> <br> **Self-Joins:** Often, a correlated subquery can be rewritten as a self-join for better performance and readability. For the example above: <br> `SELECT e.EmployeeName, e.Salary FROM Employees e JOIN (SELECT DepartmentID, AVG(Salary) AS AvgDeptSalary FROM Employees GROUP BY DepartmentID) d ON e.DepartmentID = d.DepartmentID WHERE e.Salary > d.AvgDeptSalary;` |
| **Non-Correlated Subquery** | A subquery that does not depend on the outer query for its values. It executes independently and typically only once. | `SELECT ProductName FROM Products WHERE Price > (SELECT AVG(Price) FROM Products);` <br> (Finds products with a price greater than the overall average product price) | **Efficiency:** Generally more efficient than correlated subqueries as they are executed once. <br> <br> **Clarity:** Often easier to understand as their logic is self-contained. |
